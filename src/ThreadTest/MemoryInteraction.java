package ThreadTest;

import java.lang.reflect.Executable;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 概念:
 * 临界区： 保证了同一时间 只能有一个线程访问变量的方法
 * 互斥量： 只有拥有互斥对象的线程才能够访问变量（只能有一个互斥变量）
 * 管程/信号量： （一个概念）当一个线程需要锁定，必须进入管程，其他试图进入管程的线程必须挂起，直到管程中的线程退出
 *
 * 重排序： 处理器会对输入的代码进行乱序执行优化，再将结果重组，保证和顺序执行的结果相同。
 * （能使处理器内部的计算单元尽可能充分的被利用，提高效率）
 * 但可能导致线程安全问题 （比如重排序后 导致线程的 flag位提前改变）
 * ----------------------------------------------------------------------------------------------------------------------------------
 * Java线程    工作内存  ——|------|
 *                          |  主  |
 * Java线程    工作内存  ——|  内  |
 *                          |  存  |
 * Java线程    工作内存  ——|------|
 * ----------------------------------------------------------------------------------------------------------------------------------
 * 深入浅出Java虚拟机 12章
 * 内存间交互操作，
 * lock（锁定）：作用于主内存的变量，它把一个变量标识为一个线程独占的状态；
 * unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
 * read（读取）：作用于主内存的变量，它把一个变量的值从主内存传送到线程中的工作内存，以便随后的load动作使用；
 * load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中；
 * use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎；
 * assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量；
 * store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作；
 * write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值写入主内存的变量中；
 *
 * 知识点：！！！！！
 * read和load store和write必须成对出现
 * 不允许线程丢弃一个刚assign操作的变量（必须写回到主存中）
 * 不允许一个线程将一个没有发生过任何assign操作的数据从工作内存同步回主存
 * 变量只能从主存中诞生，工作内存中的变量必须是 load 或者 assign 初始化后的。
 * lock操作可以对同一个变量反复执行多次，需要执行相同次数的unlock操作，变量才能解锁
 *
 * 对变量lock时，清空工作内存中该变量的值
 * 执行引擎使用该变量时，需重新执行load/assign操作初始化该变量的值
 * 对变量unlck时，需要先将变量同步到主存中（store  write)
 * ----------------------------------------------------------------------------------------------------------------------------------
 *  多个线程在处理一个共享变量的时候，出现线程安全问题
 *  多线程中，每一个线程都有自己独立的cache，部分数据修改在cache中，还没写到内存中，造成数据不一致问题
 *  处理线程安全问题 方法
 *  volatile 和 synchronized
 * ----------------------------------------------------------------------------------------------------------------------------------
 * volatile 可见性， 当声明一个变量为volatile 时， 该变量具可见性，
 * 即当一个线程修改它时，其他线程会知道自己 工作内存 中的该变量已经被修改了，从而直接去内存中读取该变量，而不是使用自己工作内存中的变量副本。
 * （除了volatile  ， final和synchronized 也能实现可见性
 *
 * volatile 有序性，（禁止指令重排序优化），当声明一个变量为volatile 时
 * 该变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行
 * （但它前面的代码可以重排序，它后面的代码也可以重排序）
 *
 * 但volatile 不能保证线程安全，因为Java里的运算不是 原子操作 ！！！
 * （t = t + 1, 当 线程1 对t 进行加1操作后，还没在主存中修改t 的值，如果转而执行线程2，那么t 的值就出现了问题
 *
 * volatile如何保证线程安全！！！
 *  运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
 *  变量不需要与其他状态变量共同参与不变约束。
 *
 * volatile 大多数情况下的性能要比用锁要好
 * ----------------------------------------------------------------------------------------------------------------------------------
 * synchronized 同步块  （具有原子性 可见性 有序性）
 * synchronized 指定了对象参数，
 *
 * 它有一个从 偏向锁 到轻量级锁（自旋锁/自适应自旋锁） 到重量级锁（互斥锁）的过渡过程
 * ----------------------------------------------------------------------------------------------------------------------------------
 *
 * 先行发生 和 时间上的先发生 两者不是相同的概念，
 * 时间先后顺序与线性发生原则之间基本没有太大的关系，
 *
 * ！！！所以衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准
 *
 * ----------------------------------------------------------------------------------------------------------------------------------
 * 缓存一致性协议
 * 线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在其他处理器的操作情况，
 * 一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。
 * 所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问。
 * ----------------------------------------------------------------------------------------------------------------------------------
 *
 * native 方法的作用
 * native 方法是java调用非java代码的接口,该方法由非Java语言实现
 *
 * 用处：
 * 1 与Java环境外进行交互
 * 2 与操作系统交互
 *
 * ----------------------------------------------------------------------------------------------------------------------------------
 * final 方法的作用
 *
 * 修饰 基本类型，变量不可再被赋值
 * 修饰 引用类型，参数变量引用的对象不能被改变，对象的值可以修改（不能再引用新的对象）
 * 修饰 方法， 该方法不能在子类中被重写
 * 修饰 类，该类不能被继承，类内属性和方法不能被修改
 */
public class MemoryInteraction {
    public static  void main(String[] args){
        ExecutorService es = Executors.newFixedThreadPool(30);

    }

}
